# 前缀和

对于一个数列

```
a1, a2, a3, ……, an
```

有前缀和

```
Si = a1 + a2 + …… + ai
规定S0 = 0
```

作用：能够快速地求出原数列中一段数的和。

```
对于[l, r] 这一段数列，普通暴力是从al, al + 1, al + 2,……,ar.
时间复杂度为O(n)

前缀和则为Sr - Sl - 1
时间复杂度为O(1)
```

## 例题一

以 acwing 基础算法课**795. 前缀和**为例。

https://www.acwing.com/problem/content/797/

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int arr[N], S[N], n, m;

int main(void)
{
	scanf("%d%d", &n, &m);

	for (int i = 1; i <= n; ++ i)
	{
		scanf("%d", &arr[i]);
        //对于S[i]为其前面数列的和加上arr[i]
		S[i] = S[i - 1] + arr[i];
	}

	for (int i = 1; i <= m; ++ i)
	{
		int l, r;
		scanf("%d%d", &l, &r);
		printf("%d\n", S[r] - S[l - 1]);
	}

	return 0;
}
```

## 差分

差分是前缀和的逆运算。

```
对于a1, a2, ……, an
构造b1, b2, ……, bn
使得ai = b1 +b2 + …… + bi
则有
b1 = a1 - 0
b2 = a2 - a1
……
bn = an - an - 1

可以推导出
a1 = b1 + 0
a2 = b2 + b1
……
an = bn + …… + b2 + b1

所以在[l, r] 上的数列加一个数c
可以对bl加上c，使得al到an的所有数都加上c
对br + 1 减去c，使得ar + 1到an的所有数都减去c
这样操作的结果就算只对[l, r]上所有的数都加上c
减去c同理

由b数列得到a数列的时间复杂度为O(n)
```

## 例题二

以 acwing 基础算法课**797. 差分**为例。

https://www.acwing.com/problem/content/799/

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int arr[N], b[N], n, m, res;

int main(void)
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i)
    {
        scanf("%d", &arr[i]);
        b[i] = arr[i] - arr[i - 1];
    }

    for (int i = 1; i <= m; ++ i)
    {
        int l, r, c;

        scanf("%d%d%d", &l, &r, &c);
        b[l] += c;
        b[r + 1] -= c;
    }

    for (int i = 1; i <= n; ++ i)
    {
        res += b[i];
        printf("%d ", res);
    }
    return 0;
}
```
